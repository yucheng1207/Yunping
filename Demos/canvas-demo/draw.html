<!DOCTYPE html>
<meta charset="utf-8" />
<body>
    <canvas class="canvas" id="myCanvas"></canvas>
    <div class="tool">
        <div class="left">
            取点间隔：
            <input class="input" type="number" id="intervalInput" value="20" />
            <div class="buttons">
                <input
                    class="button"
                    type="button"
                    id="pointSide"
                    value="边取点"
                />
                <input
                    class="button"
                    type="button"
                    id="pointArea"
                    value="区域取点"
                />
                <input
                    class="button"
                    type="button"
                    id="cleanButton"
                    value="清空画布"
                />
            </div>
            <div class="tip">单击在画布取点， 双击自动闭合绘制成多边形</div>
            <div id="coordinateText" class="coordinate"></div>
        </div>
        <div class="right">
            <input
                id="switchButton"
                class="switchButton"
                type="checkbox"
                checked
            />
            自动取点
        </div>
    </div>
    <div class="datumTypeButton">
        <input id="datumTypeButton" type="checkbox" checked />
        以外接矩形作为栅格起点进行取点
    </div>
</body>

<style>
    * {
        box-sizing: border-box;
        user-select: none;
    }
    body {
        margin: 0;
        width: 100vw;
        height: 100vh;
    }
    .tool {
        position: absolute;
        height: 45px;
        top: 0;
        padding: 10px 24px;
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .canvas {
        background-color: #f1f1f1;
        cursor: crosshair;
    }
    .buttons {
        margin: 0 10px;
    }
    .button {
        margin: 0 5px;
        cursor: pointer;
    }
    .input {
        width: 60px;
    }
    .left {
        display: flex;
        align-items: center;
    }
    .right {
        display: flex;
        align-items: center;
    }
    .tip {
        font-size: 14px;
    }
    .coordinate {
        font-size: 14px;
    }
    .switchButton {
        margin-left: 8px;
    }
    .datumTypeButton {
        position: absolute;
        top: 45px;
        left: 20px;
    }
</style>

<script>
    const canvas = document.getElementById('myCanvas');
    const pointSide = document.getElementById('pointSide');
    const pointArea = document.getElementById('pointArea');
    const intervalInput = document.getElementById('intervalInput');
    const switchButton = document.getElementById('switchButton');
    const cleanButton = document.getElementById('cleanButton');
    const coordinateText = document.getElementById('coordinateText');
    const datumTypeButton = document.getElementById('datumTypeButton');

    // 设置画布宽高为整个屏幕
    const pageWidth = document.documentElement.clientWidth;
    const pageHeight = document.documentElement.clientHeight;
    canvas.width = pageWidth;
    canvas.height = pageHeight;

    // 默认取点间隔为20
    let interval = 20;

    // 颜色设置
    const lineColor = 'black'; // 线的颜色
    const gridColor = '#dcdcdc'; // 栅格颜色
    const pointColor = 'black'; // 多边形顶点的颜色
    const sidePointColor = 'red'; // 边间隔取点时点的颜色
    const polygonPointColor = 'blue'; // 区域间隔取点时点的颜色
    const polygonColor = '#e2b2b24d'; // 多边形填充颜色
    const gridLineWidth = 1; // 栅格线宽
    const lineWidth = 2; // 默认线宽
    const pointRadius = 1; // 默认点半径

    let painting = false; // 是否正在绘制多边形
    let points = []; // 多边形顶点
    let timer = null; // timer，用于处理单双击事件
    let autoPoint = true; // 是否自动取点

    // 栅格坐标基准类型: 'polygon' | 'default'
    // polygon: 多边形外接矩形的左上角为坐标为栅格基准点；default：(0，0)为栅格基准点
    // 这个值会影响最终取点位置
    let gridCoordinateDatumType = 'polygon';

    test();

    /**
     * 绘制一个测试多边形
     */
    function test() {
        points = [
            { x: 300, y: 455 },
            { x: 300, y: 353 },
            { x: 365, y: 275 },
            { x: 405, y: 410 },
            { x: 480, y: 395 },
            { x: 565, y: 395 },
            { x: 633, y: 395 },
            { x: 684, y: 295 },
            { x: 586, y: 295 },
            { x: 560, y: 355 },
            { x: 520, y: 260 },
            { x: 592, y: 195 },
            { x: 790, y: 315 },
            { x: 700, y: 488 },
            { x: 800, y: 495 },
            { x: 700, y: 588 },
            { x: 610, y: 613 },
            { x: 529, y: 610 },
            { x: 504, y: 541 },
            { x: 410, y: 606 },
            { x: 341, y: 415 },
        ];
        draw(true, true);
    }

    datumTypeButton.onclick = function (e) {
        gridCoordinateDatumType = e.target.checked ? 'polygon' : 'default';
        draw(true);
    };

    /**
     * 清空画布
     */
    cleanButton.onclick = function (e) {
        points = [];
        clean();
    };

    /**
     * 是否自动取点
     */
    switchButton.onchange = function (e) {
        autoPoint = e.target.checked;
        draw(true);
    };

    /**
     * 改变取点间隔
     */
    intervalInput.oninput = function (e) {
        interval = Number(e.target.value);
        draw(true);
    };

    /**
     * 双击画布闭合线段，绘制多边形
     */
    canvas.ondblclick = function (e) {
        clearTimeout(timer); // 清除第二个单击事件
        console.log('双击', points);
        painting = false;
        draw(true);
    };

    /**
     * 点击画布开始绘制多边形
     */
    canvas.onclick = function (e) {
        clearTimeout(timer); // 清除第一个单击事件
        if (!painting && points.length) {
            if (confirm('需要重新绘制多边形吗？')) {
                // 画第一个点前先清空points和画布
                points = [];
                clean();
                return;
            } else {
                return;
            }
        }
        timer = setTimeout(function () {
            painting = true;
            let x = e.clientX;
            let y = e.clientY;
            console.log('单击', { x, y });
            if (!points.find((item) => item.x === x && item.y === y)) {
                points.push({ x, y });
                draw(false);
            }
        }, 250);
    };

    /**
     * 移动鼠标获取鼠标坐标值
     */
    canvas.onmousemove = function (e) {
        const x = e.clientX;
        const y = e.clientY;
        coordinateText.innerText = `（${x}，${y}）`;
    };

    pointSide.onclick = function () {
        pointPolygonSide();
    };

    pointArea.onclick = function () {
        pointPolygonInternal();
    };

    /**
     * 获取外接矩形
     */
    function getCircumscribedRectangle() {
        const xSort = points.map((item) => item.x).sort((a, b) => a - b);
        const ySort = points.map((item) => item.y).sort((a, b) => a - b);
        const top = ySort[0];
        const right = xSort[xSort.length - 1];
        const bottom = ySort[ySort.length - 1];
        const left = xSort[0];
        const topLeft = { x: left, y: top };
        const topRight = { x: right, y: top };
        const bottomRight = { x: right, y: bottom };
        const bottomLeft = { x: left, y: bottom };
        return {
            top,
            right,
            bottom,
            left,
            topLeft,
            topRight,
            bottomRight,
            bottomLeft,
        };
    }
    /**
     * 获取ctx
     */
    function getCtx() {
        return canvas.getContext('2d');
    }
    /**
     * 获取离`currentVaule`最接近的间隔值（以initialValue为起点，interval为间隔得到一组值，得到这组值中离currentVaule最近的值）
     * @param currentVaule - 当前值
     * @param initialValue - 开始值， gridCoordinateDatumType为‘default’时，栅格起点为(0，0),所以initialValue会被强制设置为0
     * @param vauleInterval - 间隔
     * @param mathIntegerType - 取整类型，floor：向下取整；ceil：向上取整
     * @returns
     */
    function getNearestVaule(
        currentVaule,
        initialValue,
        vauleInterval,
        mathIntegerType
    ) {
        if (gridCoordinateDatumType === 'default') {
            // gridCoordinateDatumType为‘default’时，栅格起点为(0，0),所以initialValue会被强制设置为0
            initialValue = 0;
        }
        if (mathIntegerType === 'ceil') {
            // 向上取整
            return (
                initialValue +
                Math.ceil((currentVaule - initialValue) / vauleInterval) *
                    vauleInterval
            );
        } else if (mathIntegerType === 'floor') {
            // 向下取整
            return (
                initialValue +
                Math.floor((currentVaule - initialValue) / vauleInterval) *
                    vauleInterval
            );
        } else {
            console.error(
                '取整类型设置错误, 只能是“ceil”或“floor”',
                integerType
            );
        }
    }
    /**
     * 绘制结果
     */
    function draw(isPolygon, showGrid = true) {
        const ctx = getCtx();
        clean();
        if (!points.length) return;
        // 绘制多边形顶点
        points.forEach((item) => {
            drawPoint(item.x, item.y, 2);
        });
        if (showGrid) {
            drawGrid();
        }
        if (isPolygon) {
            // 形成闭合的多边形
            if (points.length > 2 && points[0] !== points[points.length - 1]) {
                points.push(points[0]);
            }
            drawPolygon(points);
        } else {
            drawLine(points, 2);
        }

        // 自动取点
        if (autoPoint) {
            points.length >= 2 && pointPolygonSide();
            points.length >= 3 && !painting && pointPolygonInternal();
        }
    }
    /**
     * 多边形内部均匀取点
     */
    function pointPolygonInternal() {
        try {
            const { top, right, bottom, left } = getCircumscribedRectangle(); // 取外接矩形
            console.log('外接矩形', {
                top,
                right,
                bottom,
                left,
            });
            const rows = {}; // 用于存储多边形每条边跟横向栅格线的交点

            console.log('points', points);
            points.forEach((item, index) => {
                if (index >= points.length - 1) {
                    return; // 最后一个点
                }
                // 获取边的两个顶点
                const point1 = item;
                const point2 = points[index + 1];

                // 计算这条边对应的一次方程k和b
                const isVerticalLine = point1.x === point2.x; // 垂直线，竖线，无法得出一次方程
                const k = !isVerticalLine
                    ? (point1.y - point2.y) / (point1.x - point2.x)
                    : 0;
                const b = point1.y - k * point1.x;

                if (gridCoordinateDatumType === 'default') {
                    initialValue = 0;
                }
                const minY = Math.min(point1.y, point2.y);
                const maxY = Math.max(point1.y, point2.y);
                if (minY === maxY) {
                    // 水平的边，不需要打点
                    return;
                }
                // 获取与线段有交点的横向栅格线范围
                const minGridY = getNearestVaule(minY, top, interval, 'ceil');
                const maxGridY = getNearestVaule(maxY, top, interval, 'floor');

                for (
                    let key = minGridY;
                    key <= maxGridY;
                    key = key + interval
                ) {
                    const isPoint1 = key === point1.y; // point1在横栅格线上
                    const isPoint2 = key === point2.y; // point2在横栅格线上
                    const linearEquation = !isVerticalLine
                        ? (key - b) / k
                        : point1.x; // 求x的一次方程，  当线段为时无法得出一次方程，直接取point1.x
                    const p = {
                        x: isPoint1
                            ? point1.x
                            : isPoint2
                            ? point2.x
                            : linearEquation, // 当p点是顶点时直接使用一次方程公式算出来的x可能会跟顶点的x有很小的误差(比如顶点x为512， 算出来可能是519.99999999)，所以这里当p点是顶点时直接去顶点的x值
                        y: key,
                        index,
                    };

                    let isTangent = false;
                    console.log(key, point1, point2);
                    if (isPoint1) {
                        // point1在横栅格线上
                        const isFirstVertex = index === 0;
                        const previousVertex = isFirstVertex
                            ? points[points.length - 2]
                            : points[index - 1];
                        const nextVertex = point2;
                        isTangent =
                            Math.sign(previousVertex.y - key) ===
                            Math.sign(nextVertex.y - key); // 前后两个点在同一侧，说明该顶点与横向栅格线相切
                        console.log('isTangent1', isTangent, p);
                    }
                    if (isPoint2) {
                        // point2在横栅格线上
                        const isLastVertex = index + 1 === points.length - 1;
                        const previousVertex = point1;
                        const nextVertex = isLastVertex
                            ? points[1]
                            : points[index + 2];
                        isTangent =
                            Math.sign(previousVertex.y - key) ===
                            Math.sign(nextVertex.y - key); // 前后两个点在同一侧，说明该顶点与横向栅格线相切
                        console.log('isTangent2', isTangent, p);
                    }

                    // 将多边形每条边跟横向栅格线的交点存储到rows对象中，rows对象的每个key值为该行栅格线的Y值
                    if (!rows[`${key}`]) {
                        rows[`${key}`] = !isTangent ? [p] : [];
                    } else {
                        const currentRow = rows[`${key}`];
                        const rowFirstPoint = currentRow[0]; // 该行第一个点
                        const rowLastPoint = currentRow[currentRow.length - 1]; // 该行最后一个点
                        const hasSamePoint =
                            rowFirstPoint &&
                            rowLastPoint &&
                            (p.x === rowFirstPoint.x || p.x === rowLastPoint.x); // 去重，新加的点不等于该行的上一个点和该行的第一个点

                        if (!hasSamePoint && !isTangent) {
                            currentRow.push(p);
                        }
                    }
                }
            });
            console.log('每条边与横向栅格线的交点：', rows);
            const pointsSave = [];
            Object.values(rows).forEach((_item) => {
                const rowPoints = _item.sort((a, b) => a.x - b.x); // 排序
                if (rowPoints.length % 2) {
                    // rowPoints不是偶数，取点出现问题
                    const error = {
                        message: `rows的 ${rowPoints[0].y}行 排序并去重后不是偶数，取点出现问题`,
                        row: rowPoints,
                        rows,
                    };
                    throw error; // 直接报错，不继续绘制剩余的点
                    // console.error(error.message, error);
                    // return; // 继续绘制剩余的点
                }
                // 在两个交点之间均匀取点
                for (let i = 0; i <= rowPoints.length - 1; i = i + 2) {
                    const startPoint = rowPoints[i];
                    const endPoint = rowPoints[i + 1];
                    const pointY = startPoint.y;
                    const startX = getNearestVaule(
                        startPoint.x,
                        left,
                        interval,
                        'ceil'
                    );
                    for (
                        let pointX = startX;
                        pointX <= endPoint.x;
                        pointX = pointX + interval
                    ) {
                        pointsSave.push({ x: pointX, y: pointY });
                        drawPoint(
                            pointX,
                            pointY,
                            pointRadius,
                            polygonPointColor
                        );
                    }
                }
            });
            console.log('每条边与横向栅格线的交点(处理后)：', rows);
            console.log('多边形内部取点结果：', pointsSave);
        } catch (error) {
            console.error('多边形内部取点失败', error);
        }
    }
    /**
     * 给多边形的边取点
     */
    function pointPolygonSide() {
        points.forEach((p, index) => {
            if (index < points.length - 1) {
                pointLineSegment([p, points[index + 1]]);
            }
        });
    }
    /**
     * 给线段取点
     */
    function pointLineSegment(lineSegment) {
        try {
            if (interval && lineSegment && lineSegment.length === 2) {
                const point1 = lineSegment[0];
                const point2 = lineSegment[1];
                const a = point2.y - point1.y;
                const b = point2.x - point1.x;
                const c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2));
                const n = Math.floor(c / interval);
                const p = [];
                for (let i = 1; i <= n; i++) {
                    const x = (b / c) * (interval * i) + point1.x;
                    const y = (a / c) * (interval * i) + point1.y;
                    p.push({ x, y });
                    drawPoint(x, y, 2, sidePointColor);
                }
                return p;
            } else {
                console.error('线段取点失败', lineSegment, interval);
            }
        } catch (error) {
            console.error('线段取点失败', error);
        }
    }
    /**
     * 绘制栅格
     */
    function drawGrid() {
        try {
            const { top, right, bottom, left } = getCircumscribedRectangle();

            // // 画外接矩形 - Circumscribed rectangle
            // const topLeft = { x: left, y: top };
            // const topRight = { x: right, y: top };
            // const bottomRight = { x: right, y: bottom };
            // const bottomLeft = { x: left, y: bottom };
            // drawLine(
            //     [topLeft, topRight, bottomRight, bottomLeft, topLeft],
            //     gridLineWidth,
            //     gridColor
            // );
            const isDefaultDatum = gridCoordinateDatumType === 'default';
            const gridLeft = isDefaultDatum ? 0 : left; // Math.floor(left / interval) * interval;
            const gridRight = isDefaultDatum ? pageWidth : right; // Math.ceil(right / interval) * interval;
            const gridTop = isDefaultDatum ? 0 : top; // Math.floor(top / interval) * interval;
            const gridBottom = isDefaultDatum ? pageHeight : bottom; // Math.ceil(bottom / interval) * interval;
            // 画竖线
            for (let i = gridLeft; i <= gridRight; i = i + interval) {
                drawLine(
                    [
                        { x: i, y: gridTop },
                        { x: i, y: gridBottom },
                    ],
                    gridLineWidth,
                    gridColor
                );
            }
            // 画横线
            for (let i = gridTop; i <= gridBottom; i = i + interval) {
                drawLine(
                    [
                        { x: gridLeft, y: i },
                        { x: gridRight, y: i },
                    ],
                    gridLineWidth,
                    gridColor
                );
            }
        } catch (error) {
            console.error('栅格绘制失败', error);
        }
    }

    /**
     * 绘制点
     */
    function drawPoint(x, y, radius, color) {
        const ctx = getCtx();
        //绘制点
        ctx.beginPath(); //开始绘制
        ctx.strokeStyle = color || pointColor;
        ctx.arc(x, y, radius || pointRadius, 0, Math.PI * 2, true);
        ctx.fill();
        ctx.stroke(); //进行绘制
    }
    /**
     * 绘制线段
     */
    function drawLine(lines, width, color) {
        const ctx = getCtx();
        ctx.beginPath(); //开始绘制
        ctx.lineWidth = width || lineWidth;
        ctx.strokeStyle = color || lineColor;
        lines.forEach((item) => {
            ctx.lineTo(item.x, item.y); //终点,或者理解为下一个点
        });
        ctx.stroke(); //进行绘制
    }
    /**
     * 绘制多边形
     */
    function drawPolygon(lines, isfill = true) {
        if (lines.length > 2) {
            const ctx = getCtx();
            ctx.beginPath(); //开始绘制
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = lineColor;
            lines.forEach((item) => {
                ctx.lineTo(item.x, item.y); //终点,或者理解为下一个点
            });
            if (isfill) {
                ctx.fillStyle = polygonColor;
                ctx.fill();
            }
            ctx.stroke(); //进行绘制
        } else {
            console.error('绘制多边形失败', lines);
        }
    }
    /**
     * 清空画布
     */
    function clean() {
        const canvas = document.getElementById('myCanvas');
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (gridCoordinateDatumType === 'default') {
            drawGrid();
        }
    }
</script>
